<div id = "tactical-grid">
    <div id = "tool-bar">
        <div id = "toggle-buttons">
            <div id = "halfcourt-button">
                <button id = "halfcourt" type = "button" onclick="background_to_halfcourt()">Halfcourt!</button>
            </div>
            <div id = "fullcourt-button">
                <button id = "fullcourt" type = "button" onclick="background_to_fullcourt()">Fullcourt!</button>
            </div>
        </div>
        <div id = "drawing-buttons">
           <button id = "run" type = "button" onclick="lineToRun(event)"> RUN </button>
           <button id = "pass" type = "button" onclick="lineToPass(event)"> PASS </button>
           <button id = "drive" type = "button" onclick="lineToDribble(event)"> DRIBBLE </button>
           <button id = "screen" type = "button" onclick="lineToScreen(event)"> SCREEN </button>
        </div>
        <div id = "save-block">SAVE</div>
    </div>
    <canvas id ="c"></canvas>
</div>

<script>




    /*********************************************************************************************************************************/
    /**************************************************** <GLOBAL VARIABLES> *********************************************************/
    /*********************************************************************************************************************************/
    var fullcourt_ratio = 1.754;
    var halfcourt_ratio = .88;
    var playerRadius = 20;
    var anchorRadius = 3;
    var anchorOffset = anchorRadius - .5;

    var line_type;
    
    var line, isDown, evented;

    var canvas = new fabric.Canvas('c',{
        targetFindTolerance: 15,
         perPixelTargetFind: true,
         preserveObjectStacking: true,
    }); 

    canvas.setHeight(window.innerHeight);
    canvas.setWidth(window.innerWidth * .85);

    halfcourt_img_width = window.innerHeight / halfcourt_ratio;
    halfcourt_img_left = canvas.width / 2 - halfcourt_img_width /2;
    fullcourt_img_width = window.innerHeight / fullcourt_ratio;
    fullcourt_img_left = canvas.width / 2 - fullcourt_img_width /2;
    var bench = (canvas.width - (halfcourt_img_width + halfcourt_img_left))/2 + halfcourt_img_width + halfcourt_img_left;

    /*********************************************************************************************************************************/
    /**************************************************** <GLOBAL VARIABLES/> ********************************************************/
    /*********************************************************************************************************************************/







    /*********************************************************************************************************************************/
    /**************************************************** <DRAWING OBJECTS> **********************************************************/
    /*********************************************************************************************************************************/



    /**************************************************** <LINE WITH ARROW> **********************************************************/

    const LineWithArrow = fabric.util.createClass(fabric.Line, {
      type: 'line_with_arrow',

      initialize(element, options) {
        options || (options = {});
        this.callSuper('initialize', element, options);

        // Set default options
        this.set({
          id:   this.id,
          hasControls: false,
          selectable: true,
          hasBorders: false,
          evented: true,
          perPixelTargetFind: true,
        });
        this.lines = [];
      },

      _render(ctx) {
        this.callSuper('_render', ctx);
        ctx.save();
        const xDiff = this.x2 - this.x1;
        const yDiff = this.y2 - this.y1;
        const angle = Math.atan2(yDiff, xDiff);
        ctx.translate((this.x2 - this.x1) / 2, (this.y2 - this.y1) / 2);
        ctx.rotate(angle);
        this.anchorAngle = angle;
        ctx.beginPath();
        // Move 5px in front of line to start the arrow so it does not have the square line end showing in front (0,0)
        ctx.moveTo(5, 0);
        ctx.lineTo(-5, 5);
        ctx.lineTo(-5, -5);
        ctx.closePath();
        ctx.fillStyle = this.stroke;
        ctx.fill();
        ctx.restore();
      },

      toObject() {
        return fabric.util.object.extend(this.callSuper('toObject'), {
          customProps: this.customProps,
        });
      },
    });

    /********************************************************* <LINE WITH ARROW/> *****************************************************/






    /************************************************************ <PASS LINE> *********************************************************/

    const PassLine = fabric.util.createClass(fabric.Line, {
      type: 'pass_line',
      strokeDashArray: [5, 5],

      initialize(element, options) {
        options || (options = {});
        this.callSuper('initialize', element, options);

        // Set default options
        this.set({
          id:   this.id,
          hasControls: false,
          selectable: true,
          hasBorders: false,
          evented: true,
          perPixelTargetFind: true,
        });
        this.lines = [];
      },

      _render(ctx) {
        this.callSuper('_render', ctx);
        ctx.save();
        const xDiff = this.x2 - this.x1;
        const yDiff = this.y2 - this.y1;
        const angle = Math.atan2(yDiff, xDiff);
        ctx.translate((this.x2 - this.x1) / 2, (this.y2 - this.y1) / 2);
        ctx.rotate(angle);
        this.anchorAngle = angle;
        ctx.beginPath();
        // Move 5px in front of line to start the arrow so it does not have the square line end showing in front (0,0)
        ctx.moveTo(5, 0);
        ctx.lineTo(-5, 5);
        ctx.lineTo(-5, -5);
        ctx.closePath();
        ctx.fillStyle = this.stroke;
        ctx.fill();
        ctx.restore();
      },

      toObject() {
        return fabric.util.object.extend(this.callSuper('toObject'), {
          customProps: this.customProps,
        });
      },
    });

    /************************************************************ <PASS LINE/> ********************************************************/






    /************************************************************ <SCREEN LINE> *******************************************************/

    const ScreenLine = fabric.util.createClass(fabric.Line, {
      type: 'screen_line',

      initialize(element, options) {
        options || (options = {});
        this.callSuper('initialize', element, options);

        // Set default options
        this.set({
          id:   this.id,
          hasControls: false,
          hasBorders: false,
          selectable: true,
          evented: true,
          perPixelTargetFind: true,
        });
        this.lines = [];
      },

      _render(ctx) {
        this.callSuper('_render', ctx);
        ctx.save();
        const xDiff = this.x2 - this.x1;
        const yDiff = this.y2 - this.y1;
        const angle = Math.atan2(yDiff, xDiff);
        ctx.translate((this.x2 - this.x1) / 2, (this.y2 - this.y1) / 2);
        ctx.rotate(angle);
        this.anchorAngle = angle;
        ctx.beginPath();
        // Move 5px in front of line to start the arrow so it does not have the square line end showing in front (0,0)
        ctx.moveTo(0, -10);
        ctx.lineTo(0, 10);
        ctx.stroke()
        ctx.closePath();
        ctx.strokeStyle = this.stroke;
        //ctx.fill();
        ctx.restore();
      },

      toObject() {
        return fabric.util.object.extend(this.callSuper('toObject'), {
          customProps: this.customProps,
        });
      },
    });

    /************************************************************ <SCREEN LINE/> ******************************************************/







    /************************************************************ <DRIBBLE LINE> ******************************************************/

    const DribbleLine = fabric.util.createClass(fabric.Line, {
      type: 'dribble_line',

      initialize(element, options) {
        options || (options = {});
        this.callSuper('initialize', element, options);

        // Set default options
        this.set({
          id:   this.id,
          hasControls: false,
          hasBorders: false,
          selectable: true,
          evented: true,
          perPixelTargetFind: true,
        });
        this.lines = [];
      },

      _render(ctx) {
        //this.callSuper('_render', ctx);
        ctx.save();
      const xDiff = this.x2 - this.x1;
      const yDiff = this.y2 - this.y1;
      const angle = Math.atan2(yDiff, xDiff);
      ctx.translate(xDiff / 2, yDiff / 2);
      ctx.rotate(angle);
      this.anchorAngle = angle;
      ctx.beginPath();
      // Move 5px in front of line to start the arrow so it does not have the square line end showing in front (0,0)
      ctx.moveTo(5, 0);
      ctx.lineTo(-5, 5);
      ctx.lineTo(-5, -5);
      ctx.closePath();
      ctx.fillStyle = this.stroke;
      ctx.fill();
      ctx.restore();
      var p = this.calcLinePoints();
      var point = this.pointOnLine(this.point(p.x2, p.y2), this.point(p.x1, p.y1), 10)
      this.wavy(this.point(p.x1, p.y1), point, this.point(p.x2, p.y2), ctx);
      ctx.stroke();
      },

      point: function(x, y) {
          return {
            x: x,
            y: y
          };
      },

      wavy: function(from, to, endPoint, ctx) {
          var cx = 0,
            cy = 0,
            fx = from.x,
            fy = from.y,
            tx = to.x,
            ty = to.y,
            i = 0,
            step = 2,
            waveOffsetLength = 0,

            ang = Math.atan2(ty - fy, tx - fx),
            distance = Math.sqrt((fx - tx) * (fx - tx) + (fy - ty) * (fy - ty)),
            amplitude = -10,
            f = Math.PI * distance / 20;

          for (i; i <= distance; i += step) {
            waveOffsetLength = Math.sin((i / distance) * f) * amplitude;
            cx = from.x + Math.cos(ang) * i + Math.cos(ang - Math.PI / 2) * waveOffsetLength;
            cy = from.y + Math.sin(ang) * i + Math.sin(ang - Math.PI / 2) * waveOffsetLength;
            i > 0 ? ctx.lineTo(cx, cy) : ctx.moveTo(cx, cy);
          }
          ctx.lineTo(to.x, to.y);
          ctx.lineTo(endPoint.x, endPoint.y);
    },

    pointOnLine: function(point1, point2, dist) {
      var len = Math.sqrt(((point2.x - point1.x) * (point2.x - point1.x)) + ((point2.y - point1.y) * (point2.y - point1.y)));
      var t = (dist) / len;
      var x3 = ((1 - t) * point1.x) + (t * point2.x),
        y3 = ((1 - t) * point1.y) + (t * point2.y);
      return new fabric.Point(x3, y3);
    },

      toObject() {
        return fabric.util.object.extend(this.callSuper('toObject'), {
          customProps: this.customProps,
        });
      },
    });


    /************************************************************ <DRIBBLE LINE/> *****************************************************/






    /********************************************************** <DRAWING FUNCTIONS> ***************************************************/

    function selection() {
      changeObjSelection(true);
      canvas.off('mouse:down');
      canvas.off('mouse:move');
      canvas.off('mouse:up');
      evented = false;
    }

    function draw(anchor) {
      var line;
      changeObjSelection(false);
      if (!evented) {
        canvas.on('mouse:down', function(e){
            line = onMouseDown(anchor, line_type, e)});
        canvas.on('mouse:move', function(e){
            line = onMouseMove(e, line)});
        canvas.on('mouse:up', function(e){
            line = onMouseUp(e, line)
            anchor.lines.push(line);
            line.anchor = anchor;
            canvas.setActiveObject(line);
        });
        evented = true;
      }
    }


    function changeObjSelection(value) {
      canvas.selection = value;
      canvas.forEachObject(function(obj){
        obj.selectable = value;
      });
      canvas.requestRenderAll();
    }

    function onMouseDown(anchor, line_type, options) {
      isDown = true;
      var pointer = canvas.getPointer(options.e);
      var anchor_point = anchor.anchorPoint;
      var points = [anchor_point.x, anchor_point.y, pointer.x, pointer.y]
      
      var line = selectLine(points, anchor.color, line_type);
      line.color = anchor.color;
      canvas.add(line);
      return line;

    }

    function onMouseMove(options, line) {
      if (!isDown) return;
      var pointer = canvas.getPointer(options.e);
      line.set({
        x2: pointer.x,
        y2: pointer.y,
      });
      
      line.hasBorders = false;
      canvas.renderAll();
      return line;
    }

    function onMouseUp(options, line) {
      isDown = false;
      line.setCoords();
      var centerX = line.x2 - anchorOffset  + Math.cos(line.anchorAngle) * 10;
      var centerY = line.y2 - anchorOffset + Math.sin(line.anchorAngle) * 10;
      line.anchorPoint = new fabric.Point(line.x2 + Math.cos(line.anchorAngle) * 10, line.y2 + Math.sin(line.anchorAngle) * 10);
      //create anchor circle for future lines to anchor themselves
      line.toAnchor = new fabric.Circle({
        selectable: false,
        evented: false,
        hasControls: false,
        hasBorders: false,
        left: centerX,
        top: centerY,
        lockMovementY: true,
        lockMovementX: true,
        radius: anchorRadius,
        strokeWidth: 1,
        stroke: line.color,
        fill: "white",
      });
      line.anchorable = true;
      canvas.add(line.toAnchor);
      canvas.requestRenderAll();
      selection();
      canvas.sendToBack(line);
      return line;
    }



    function drawLineWithArrow(points, color) {
      return new LineWithArrow(points, {
        strokeWidth: 2,
        stroke: color,
        objectCaching: false,
        selectable: true,
        padding: 10
      })
    }

    function drawScreenLine(points, color) {
      return new ScreenLine(points, {
        strokeWidth: 2,
        stroke: color,
        objectCaching: false,
        selectable: true,
        padding: 10
      })
    }

    function drawPassLine(points, color) {
      return new PassLine(points, {
        strokeWidth: 2,
        stroke: color,
        objectCaching: false,
        selectable: true,
        padding: 10
      })
    }

    function drawDribbleLine(points, color) {
      return new DribbleLine(points, {
        strokeWidth: 2,
        stroke: color,
        objectCaching: false,
        selectable: true,
        padding: 10
      })
    }

    function selectLine(points, color, line_type) {
      switch(line_type){
        case "run"  :
            return drawLineWithArrow(points, color)
        case "screen" :
            return drawScreenLine(points, color);
        case "pass" :
            return drawPassLine(points, color);
        case "dribble" :
            return drawDribbleLine(points, color);
      }
      
    }

    /********************************************************** <DRAWING FUNCTIONS/> ***************************************************/






    /******************************************************** <CIRCLE> ***************************************************************/

    function makeCircle(left, top, color) {
        var c = new fabric.Circle({
          id: "player",
          left: left,
          top: top,
          strokeWidth: 3,
          radius: playerRadius,
          fill: color,
          stroke: color,
          padding: 10
        });
        c.hasBorders = false;
        c.hasControls = false;
        c.color = color;
        c.anchorPoint = new fabric.Point(left + playerRadius, top + playerRadius);
        c.anchorable = true;

        c.lines = [];

        return c;
      }

    /******************************************************** <CIRCLE/> ***************************************************************/


    /*********************************************************************************************************************************/
    /**************************************************** <DRAWING OBJECTS/> **********************************************************/
    /*********************************************************************************************************************************/


    /*********************************************************************************************************************************/
    /**************************************************** <BUTTON FUNCTIONS> *********************************************************/
    /*********************************************************************************************************************************/

    function validateValidAnchor(object){
      var isValidAnchor = false;
      var object_type = object.get("type");
      if (object_type == "circle" || object_type == "line_with_arrow" || object_type == "pass_line" || object_type == "dribble_line" || object_type == "screen_line"){
        isValidAnchor = true;
      }
      return isValidAnchor;
    }

    function lineToRun(event){
        line_type = "run";
        var anchor = canvas.getActiveObject()
            if(anchor && validateValidAnchor(anchor)){
                draw(anchor);
                canvas.renderAll();
            }    
    }

    function lineToPass(event){
        line_type = "pass";
         var anchor = canvas.getActiveObject()
            if(anchor && validateValidAnchor(anchor)){
                draw(anchor);
                canvas.renderAll();
            } 
    }

    function lineToScreen(event){
        line_type = "screen";
        var anchor = canvas.getActiveObject()
            if(anchor && validateValidAnchor(anchor)){
                draw(anchor);
                canvas.renderAll();
                
            } 
    }

    function lineToDribble(event){
        line_type = "dribble";
        var anchor = canvas.getActiveObject()
            if(anchor && validateValidAnchor(anchor)){
                draw(anchor);
                canvas.renderAll();
            } 
    }




    function background_to_halfcourt(){
        var img = new Image();
        img.onload = function() {
            // this is syncronous
            var background_img = new fabric.Image(img);
            background_img.objectCaching = false;
            background_img.scaleToHeight(window.innerHeight);

            canvas.setBackgroundImage(background_img, canvas.renderAll.bind(canvas), {
                top: 0,
                left: halfcourt_img_left
            });
            canvas.renderAll();
        };
        img.src = "<%= asset_path('halfcourt.png')%>";
    }

    function background_to_fullcourt(){
        var img = new Image();
        img.onload = function() {
            // this is syncronous
            var background_img = new fabric.Image(img);
            background_img.objectCaching = false;
            background_img.scaleToHeight(window.innerHeight);

            canvas.setBackgroundImage(background_img, canvas.renderAll.bind(canvas), {
                top: 0,
                left: fullcourt_img_left
            });
            canvas.renderAll();
        };
        img.src = "<%= asset_path('full_court.png')%>";
    }

    /*********************************************************************************************************************************/
    /**************************************************** <BUTTON FUNCTIONS/> *********************************************************/
    /*********************************************************************************************************************************/



    /*********************************************************************************************************************************/
    /**************************************************** <HELPER FUNCTIONS> *********************************************************/
    /*********************************************************************************************************************************/

    function rotateAnchor(line){
      var centerX = line.x2 - anchorOffset + (Math.cos(line.anchorAngle) * 10);
      var centerY = line.y2 - anchorOffset + (Math.sin(line.anchorAngle) * 10);
      line.toAnchor.set({top: centerY, left: centerX})
      line.anchorPoint.setXY(line.x2 + Math.cos(line.anchorAngle) * 10, line.y2 + Math.sin(line.anchorAngle) * 10);
    }


    function add_players(){

        var off1 = makeCircle(bench, 50, 'blue', null, null, null);
        var off2 = makeCircle(bench, 100, 'blue', null, null, null);
        var off3 = makeCircle(bench, 150, 'blue', null, null, null);
        var off4 = makeCircle(bench, 200, 'blue', null, null, null);
        var off5 = makeCircle(bench, 250, 'blue', null, null, null);

        var def1 = makeCircle(bench, 400, 'red', null, null, null);
        var def2 = makeCircle(bench, 450, 'red', null, null, null);
        var def3 = makeCircle(bench, 500, 'red', null, null, null);
        var def4 = makeCircle(bench, 550, 'red', null, null, null);
        var def5 = makeCircle(bench, 600, 'red', null, null, null);

        canvas.add(off1);
        canvas.add(off2);
        canvas.add(off3);
        canvas.add(off4);
        canvas.add(off5);
        canvas.add(def1);
        canvas.add(def2);
        canvas.add(def3);
        canvas.add(def4);
        canvas.add(def5);
    }

    function anchorPositioning(e){
      var obj = e.target;
      var type = obj.get('type');
      if(validateLine(obj)){
          obj.anchorPoint.setXY(canvas.getPointer(e.e).x + Math.cos(obj.anchorAngle) * 10 , canvas.getPointer(e.e).y + Math.sin(obj.anchorAngle) * 10)
          obj.set({x1: obj.anchor.anchorPoint.x, y1: obj.anchor.anchorPoint.y, x2: canvas.getPointer(e.e).x, y2: canvas.getPointer(e.e).y})
          obj.setCoords();
          rotateAnchor(obj);
      }
      else if (obj.get("id") == "player"){
          obj.anchorPoint.setXY(obj.left + playerRadius, obj.top + playerRadius);
      }  
      var line_arr_length = obj.lines.length;  
      for (var i = 0; i < line_arr_length; i++){
          obj.lines[i].set({x1: obj.anchorPoint.x, y1: obj.anchorPoint.y});
          rotateAnchor(obj.lines[i]);
          obj.lines[i].setCoords();

          var line_elem_arr_length = obj.lines[i].lines.length;
          for(var j = 0; j < line_elem_arr_length; j++){
            obj.lines[i].lines[j].set({x1: obj.lines[i].anchorPoint.x, y1: obj.lines[i].anchorPoint.y});
            obj.lines[i].lines[j].setCoords();

          }
      }
    }

    function boundObjects(obj){
      // if object is too big ignore
      if(obj.currentHeight > obj.canvas.height -1 || obj.currentWidth > obj.canvas.width -1){
          return;
      }        
      obj.setCoords();        
      // top-left  corner
      if(obj.getBoundingRect().top < 1 || obj.getBoundingRect().left < 1){
          obj.top = Math.max(obj.top, obj.top-obj.getBoundingRect().top);
          obj.left = Math.max(obj.left, obj.left-obj.getBoundingRect().left);
      }
          // bot-right corner
      if(obj.getBoundingRect().top+obj.getBoundingRect().height  > obj.canvas.height || obj.getBoundingRect().left+obj.getBoundingRect().width  > obj.canvas.width){
          obj.top = Math.min(obj.top, obj.canvas.height-obj.getBoundingRect().height+obj.top-obj.getBoundingRect().top);
          obj.left = Math.min(obj.left, obj.canvas.width-obj.getBoundingRect().width+obj.left-obj.getBoundingRect().left);
      }
    }

    function validateLine(obj){
      var type = obj.get("type");
      if (type == 'line_with_arrow' || type == 'screen_line' || type == "pass_line" || type == "dribble_line"){
        return true;
      }
      else return false;
    }

    /*********************************************************************************************************************************/
    /**************************************************** <HELPER FUNCTIONS/> ********************************************************/
    /*********************************************************************************************************************************/






    /*********************************************************************************************************************************/
    /**************************************************** <DOCUMENT ON READY> ********************************************************/
    /*********************************************************************************************************************************/

     $( document ).ready(function() {
        background_to_halfcourt();
        add_players();
    });
 

    canvas.on('selection:created', function() {
        canvas.getActiveObjects().forEach(function(o) {
            var type = o.get('type');
            var id = o.get("id")
            if(id == "player"){
                o.lockMovementY = false;
                o.lockMovementX = false;
                o.set({stroke: "black"});
            }
            if(validateLine(o)){
              o.toAnchor.animate('opacity', '1', {
                duration: 50,
                onChange: canvas.renderAll.bind(canvas),
              });
            } 
        });
    });

    canvas.on('before:selection:cleared', function() {
         canvas.getActiveObjects().forEach(function(o) {
            var type = o.get('type');
            var id = o.get("id");
            if(id == "player"){
                o.set({stroke: o.color});
            } 
            if(validateLine(o)){
              o.toAnchor.animate('opacity', '0', {
                duration: 50,
                onChange: canvas.renderAll.bind(canvas),
              });
            }       
        });
    });

    canvas.on('selection:updated', function() {
        canvas.getActiveObjects().forEach(function(o) {
            var type = o.get('type');
            var id = o.get("id");
            if(id == "player"){
                o.lockMovementY = false;
                o.lockMovementX = false;
            }   
        });
    });

    $(document).keyup(function(e){
        if(e.keyCode == 46 || e.keyCode == 8) {
            canvas.getActiveObjects().forEach(function(o) {
                var type = o.get('type');
                if(type == 'line_with_arrow' || type == 'screen_line' || type == "pass_line" || type == "dribble_line"){
                    canvas.remove(o.toAnchor);
                    canvas.remove(o);
                }   
        });
        }
    });
/*
    $(document).keydown(function(e) {
        if(e.keyCode == 16) {
            var anchor = canvas.getActiveObject();
            if(anchor && validateValidAnchor(anchor)){
                draw(anchor);
                canvas.renderAll();
            } 
        } 
    }
);*/

    canvas.on('object:moving', function (e) {
            var obj = e.target;
            if(obj.get("anchorable") == true){
              anchorPositioning(e);
            }
            boundObjects(obj);

    });

    /*********************************************************************************************************************************/
    /**************************************************** <DOCUMENT ON READY/> *******************************************************/
    /*********************************************************************************************************************************/



































/*
 * fabric.js Controls Extension
 * for fabric.js current build
 * Simon Kunz 09.02.2016 for pixolith
 * Licensed under the MIT license.
 */

/*********************************************************************************************************************************/
/**************************************************** <CUSTOMIZE CONTROLS> *******************************************************/
/*********************************************************************************************************************************/

    var fabric = window.fabric || ( window.fabric = {} ),
        minExtCompat = '1.6.0',
        isVML = function() {
            return typeof G_vmlCanvasManager !== 'undefined';
        },
        degreesToRadians = fabric.util.degreesToRadians,
        cursorOffset = {
            mt: 0, // n
            tr: 1, // ne
            mr: 2, // e
            br: 3, // se
            mb: 4, // s
            bl: 5, // sw
            ml: 6, // w
            tl: 7, // nw
        };

    if (minExtCompat.localeCompare(window.fabric.version) > -1) {
        console.warn('this extension might not be fully compatible with your version ' +
            'of fabric.js (' + window.fabric.version + ').' +
            'Consider using the latest compatible build of fabric.js (> ' + minExtCompat + ')'
        );
    }

    fabric.util.object.extend(fabric.Object.prototype, {

        /**
         * When true, image icons are loaded via the drawImage method
         * @type Boolean
         * @default false
         */

        useCustomIcons: false,

        /**
         * Sets a background-color for drawImage operations with transparency
         * @type string
         * @default transparent
         */

        cornerBackgroundColor: 'transparent',

        /**
         * Sets the shape of the background for drawImage operations with transparency
         * @type string
         * @default rect
         */

        cornerShape: '',

        /**
         * Inner Padding between Shape Background and drawn Image
         * @type int
         * @default rect
         */

        cornerPadding: 0,

        /**
         * Set a custom corner icon
         * @param {Object} obj settings and icon url.
         * @param callback function
         */

        customiseCornerIcons: function(obj, callback) {
            var setting,
                cornerConfig;

            for (setting in obj) {
                if (obj.hasOwnProperty(setting)) {

                    cornerConfig = {};

                    if (obj[setting].cornerShape !== undefined) {
                        this.cornerShape = obj[setting].cornerShape;
                    }

                    if (obj[setting].cornerBackgroundColor !== undefined) {
                        this.cornerBackgroundColor = obj[setting].cornerBackgroundColor;
                    }

                    if (obj[setting].borderColor !== undefined) {
                        this.borderColor = obj[setting].borderColor;
                    }

                    if (obj[setting].cornerSize !== undefined) {
                        this.cornerSize = obj[setting].cornerSize;
                    }

                    if (obj[setting].cornerPadding !== undefined) {
                        this.cornerPadding = obj[setting].cornerPadding;
                    }

                    if (obj[setting].icon !== undefined || Object.keys(obj)[0] === 'settings') {
                        this.useCustomIcons = true;

                        if (obj[setting].settings !== undefined) {
                            cornerConfig.settings = obj[setting].settings;
                        }

                        if (obj[setting].icon !== undefined) {
                            cornerConfig.icon = obj[setting].icon;

                            this.loadIcon(setting, cornerConfig, function() {
                                if (callback && typeof( callback ) === 'function') {
                                    callback();
                                }
                            });
                        }
                    }
                }
            }
        },

        /**
         * loads the icon image as an image src.
         * @param {Object} corner to load an icon.
         * @param cornerConfig as object containing icon url and corner specific settings
         * @param callback function.
         */

        loadIcon: function(corner, cornerConfig, callback) {
            var self = this,
                icon = new Image();

            icon.onload = function() {
                self[corner + 'Icon'] = this;

                if (cornerConfig.settings) {
                    self[corner + 'Settings'] = cornerConfig.settings;
                }

                if (callback && typeof( callback ) === 'function') {
                    callback();
                }
            };

            icon.onerror = function() {
                fabric.warn(this.src + ' icon is not an image');
            };

            if (cornerConfig.icon.match(/^http[s]?:\/\//) || cornerConfig.icon.substring(0, 2) === '//') {
                icon.crossOrigin = 'Anonymous';
            }

            icon.src = cornerConfig.icon;
        },

        /**
         * copy of the setter method for our american friends.
         * @param {Object} obj containing corner icon urls and settings.
         */

        customizeCornerIcons: function(obj) {
            this.customiseCornerIcons(obj);
        },

        /**
         * Draws corners of an object's bounding box.
         * Requires public properties: width, height
         * Requires public options: cornerSize, padding
         * @param {CanvasRenderingContext2D} ctx Context to draw on
         * @return {fabric.Object} thisArg
         * @chainable
         */

        drawControls: function(ctx) {

            if (!this.hasControls) {
                return this;
            }

            var wh = this._calculateCurrentDimensions(),
                width = wh.x,
                height = wh.y,
                scaleOffset = this.cornerSize,
                left = -(width + scaleOffset) / 2,
                top = -(height + scaleOffset) / 2,
                methodName;

            if (!this.useCustomIcons) {
                ctx.lineWidth = 1;
                ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
                ctx.strokeStyle = ctx.fillStyle = this.cornerColor;

                if (!this.transparentCorners) {
                    ctx.strokeStyle = this.cornerStrokeColor;
                }

                methodName = this.transparentCorners ? 'stroke' : 'fill';
            } else {
                methodName = 'drawImage';
            }

            ctx.save();
            this._setLineDash(ctx, this.cornerDashArray, null);

            // top-left
            this._drawControl('tl', ctx, methodName,
                left,
                top,
                this.tlIcon,
                this.tlSettings
            );

            // top-right
            this._drawControl('tr', ctx, methodName,
                left + width,
                top,
                this.trIcon,
                this.trSettings
            );

            // bottom-left
            this._drawControl('bl', ctx, methodName,
                left,
                top + height,
                this.blIcon,
                this.blSettings
            );

            // bottom-right
            this._drawControl('br', ctx, methodName,
                left + width,
                top + height,
                this.brIcon,
                this.brSettings
            );

            if (!this.get('lockUniScaling')) {

                // middle-top
                this._drawControl('mt', ctx, methodName,
                    left + width / 2,
                    top,
                    this.mtIcon,
                    this.mtSettings
                );

                // middle-bottom
                this._drawControl('mb', ctx, methodName,
                    left + width / 2,
                    top + height,
                    this.mbIcon,
                    this.mbSettings
                );

                // middle-right
                this._drawControl('mr', ctx, methodName,
                    left + width,
                    top + height / 2,
                    this.mrIcon,
                    this.mrSettings
                );

                // middle-left
                this._drawControl('ml', ctx, methodName,
                    left,
                    top + height / 2,
                    this.mlIcon,
                    this.mlSettings
                );
            }

            // middle-top-rotate
            if (this.hasRotatingPoint) {
                this._drawControl('mtr', ctx, methodName,
                    left + width / 2,
                    top - this.rotatingPointOffset,
                    this.mtrIcon,
                    this.mtrSettings
                );
            }

            ctx.restore();

            return this;
        },

        /** Draw controls either with background-shape and color (transparency) or plain image (modified core method)
         * @private
         * {string} icon url of the control
         */

        _drawControl: function(control, ctx, methodName, left, top, icon, settings) {
            if (!this.isControlVisible(control)) {
                return;
            }

            var size = this.cornerSize,
                cornerStroke = this.cornerStrokeColor || 'transparent',
                cornerBG = this.cornerBackgroundColor || 'black',
                cornerShape = this.cornerShape || 'rect',
                cornerPadding = typeof this.cornerPadding === 'number' ? this.cornerPadding : 10;

            if (settings) {
                if (settings.cornerSize) {
                    // Set the size, and also recalc left and top
                    left = left + size / 2 - settings.cornerSize / 2;
                    top = top + size / 2 - settings.cornerSize / 2;
                    size = settings.cornerSize;
                }
                cornerShape = settings.cornerShape || cornerShape;
                cornerBG = settings.cornerBackgroundColor || cornerBG;
                cornerPadding = typeof settings.cornerPadding === 'number' ? settings.cornerPadding : cornerPadding;
                cornerStroke = settings.cornerStrokeColor || cornerStroke;
            }

            if (this.useCustomIcons) {
                if (cornerShape) {
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = cornerBG;
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = cornerStroke;
                    switch (cornerShape) {
                        case 'rect':
                            ctx.fillRect(left, top, size, size);

                            if (cornerStroke) {
                                ctx.strokeRect(left, top, size, size);
                            }

                            break;
                        case 'circle':
                            ctx.beginPath();
                            ctx.arc(left + size / 2, top + size / 2, size / 2, 0, 2 * Math.PI);
                            ctx.fill();

                            if (cornerStroke) {
                                ctx.stroke();
                            }

                            ctx.closePath();
                            break;
                    }

                    if (icon !== undefined) {
                        ctx[methodName](
                            icon,
                            left + cornerPadding / 2,
                            top + cornerPadding / 2,
                            size - cornerPadding,
                            size - cornerPadding
                        );
                    }

                } else {
                    if (icon !== undefined) {
                        ctx[methodName](
                            icon,
                            left,
                            top,
                            size,
                            size
                        );
                    }
                }
            } else {
                isVML() || this.transparentCorners || ctx.clearRect(left, top, size, size);
                ctx[methodName + 'Rect'](left, top, size, size);
                if (!this.transparentCorners && cornerStroke) {
                    ctx.strokeRect(left, top, size, size);
                }
            }

        },
    });

    fabric.util.object.extend(fabric.Canvas.prototype, {
        /**
         * When true, actions can be overwritten
         * @type Boolean
         * @default false
         */

        overwriteActions: false,

        /**
         * When true, cursors are fixed
         * @type Boolean
         * @default false
         */

        fixedCursors: false,

        /**
         * setter Method for actions and cursors.
         * @param {Object} obj containing corner action and cursor url/type.
         */

        customiseControls: function(obj) {
            var setting;

            for (setting in obj) {
                if (obj.hasOwnProperty(setting)) {
                    if (obj[setting].action !== undefined) {
                        this.overwriteActions = true;
                        this.setCustomAction(setting, obj[setting].action);
                    }

                    if (obj[setting].cursor !== undefined) {
                        this.fixedCursors = true;
                        this.setCustomCursor(setting, obj[setting].cursor);
                    }
                }
            }
        },

        /**
         * loads the icon image as an image src.
         * @param {Object} corner to load an icon.
         * @param action as a string.
         */

        setCustomAction: function(corner, action) {
            this[corner + 'Action'] = action;
        },

        /**
         * loads the icon image as an image src.
         * @param {Object} corner to load an icon.
         * @param cursorUrl as a string.
         */

        setCustomCursor: function(corner, cursorUrl) {
            this[corner + 'cursorIcon'] = cursorUrl;
        },

        /**
         * copy of the setter method for our american friends.
         * @param {Object} obj containing corner action and cursor url/type.
         */

        customizeControls: function(obj) {
            this.customiseControls(obj);
        },

        /**
         * @private
         */

        _getActionFromCorner: function(target, corner, e) {
            if (!corner) {
                return 'drag';
            }

            if (corner) {
                if (this[corner + 'Action'] && this.overwriteActions) {
                    switch (corner) {
                        case 'mtr':
                            return this[corner + 'Action'] || 'rotate';
                        case 'ml':
                        case 'mr':
                            if (e[this.altActionKey]) {
                                return e[this.altActionKey] ? 'skewY' : 'scaleX';
                            }
                            return this[corner + 'Action'];
                        case 'mt':
                        case 'mb':
                            if (e[this.altActionKey]) {
                                return e[this.altActionKey] ? 'skewY' : 'scaleY';
                            }
                            return this[corner + 'Action'];
                        default:
                            return this[corner + 'Action'] || 'scale';
                    }
                } else {
                    switch (corner) {
                        case 'mtr':
                            return 'rotate';
                        case 'ml':
                        case 'mr':
                            return e[this.altActionKey] ? 'skewY' : 'scaleX';
                        case 'mt':
                        case 'mb':
                            return e[this.altActionKey] ? 'skewX' : 'scaleY';
                        default:
                            return 'scale';
                    }
                }
            }

            return false;
        },

        /**
         * @private
         * @param {Event} e Event object
         * @param {fabric.Object} target
         */
        _setupCurrentTransform: function(e, target) {
            if (!target) {
                return;
            }

            var pointer = this.getPointer(e),
                corner = target._findTargetCorner(this.getPointer(e, true)),
                action = this._getActionFromCorner(target, corner, e),
                origin = this._getOriginFromCorner(target, corner);

            if (typeof action === 'function') {
                action.call(this, e, target);

                // as of fabric 1.7.11 object cache will try to slice the action to check for scale so we need to convert this to a string
                action = 'void';
            }

            this._currentTransform = {
                target: target,
                action: action,
                corner: corner,
                scaleX: target.scaleX,
                scaleY: target.scaleY,
                skewX: target.skewX,
                skewY: target.skewY,
                offsetX: pointer.x - target.left,
                offsetY: pointer.y - target.top,
                originX: origin.x,
                originY: origin.y,
                ex: pointer.x,
                ey: pointer.y,
                lastX: pointer.x,
                lastY: pointer.y,
                left: target.left,
                top: target.top,
                theta: degreesToRadians(target.angle),
                width: target.width * target.scaleX,
                mouseXSign: 1,
                mouseYSign: 1,
                shiftKey: e.shiftKey,
                altKey: e[this.centeredKey],
            };

            this._currentTransform.original = {
                left: target.left,
                top: target.top,
                scaleX: target.scaleX,
                scaleY: target.scaleY,
                skewX: target.skewX,
                skewY: target.skewY,
                originX: origin.x,
                originY: origin.y,
            };

            if (action === 'remove') {
                this._removeAction(e, target);
            }

            if (action === 'moveUp') {
                this._moveLayerUpAction(e, target);
            }

            if (action === 'moveDown') {
                this._moveLayerDownAction(e, target);
            }

            if (typeof action === 'object') {
                if (Object.keys(action)[0] === 'rotateByDegrees') {
                    this._rotateByDegrees(e, target, action.rotateByDegrees);
                }
            }

            this._resetCurrentTransform();
        },

        /**
         * Custom remove object action
         * @private
         * @param {Event} e Event object
         * @param {fabric.Object} target
         */

        _removeAction: function(e, target) {
            var _this = this;
            if (this.getActiveObjects() && this.getActiveObjects() !== 'undefined') {
                this.getActiveObjects().forEach(function(o) {
                    o.off();
                    canvas.remove(o);
                });
                this.discardActiveObject();

                // as of fabric 1.6.3 necessary for reasons..
                setTimeout(function() {
                    _this.discardActiveObject();
                }, 0);

            } else {
                target.off();
                canvas.remove(target);

                setTimeout(function() {
                    _this.deactivateAll();
                }, 0);
            }
        },

        /**
         * Custom move up object action
         * @private
         * @param {Event} e Event object
         * @param {fabric.Object} target
         */

        _moveLayerUpAction: function(e, target) {
            if (this.getActiveObjects() && this.getActiveObjects() !== 'undefined') {
                this.getActiveObjects().forEach(function(o) {
                    o.bringForward();
                });
            } else {
                target.bringForward();
            }
        },

        /**
         * Custom move down object action
         * @private
         * @param {Event} e Event object
         * @param {fabric.Object} target
         */

        _moveLayerDownAction: function(e, target) {
            if (this.getActiveObjects() && this.getActiveObjects() !== 'undefined') {
                this.getActiveObjects().forEach(function(o) {
                    o.sendBackwards();
                });
            } else {
                target.sendBackwards();
            }
        },

        /**
         * Custom move down object action
         * @private
         * @param {Event} e Event object
         * @param {fabric.Object} target
         * @param {Integer} value of rotation
         */

        _rotateByDegrees: function(e, target, value) {
            var angle = parseInt(target.get('angle')) + value,
                needsOriginRestore = false;

            if (( target.originX !== 'center' || target.originY !== 'center' ) && target.centeredRotation) {
                target.setOriginToCenter();
                needsOriginRestore = true;
            }

            angle = angle > 360 ? angle - 360 : angle;

            if (this.getActiveObjects() && this.getActiveObjects() !== 'undefined') {
                this.getActiveObjects().forEach(function(obj) {
                    obj
                        .set('angle', angle)
                        .setCoords();
                });
            } else {
                target
                    .set('angle', angle)
                    .setCoords();
            }

            if (needsOriginRestore) {
                
            }

            this.renderAll();
        },

        /**
         * Sets either the standard behaviour cursors or if fixedCursors is true, tries to set a custom cursor
         * either by using an icon or a build-in cursor. Cursor icon extensions are matched with a regular expression.
         * @private
         * {string} corner name
         * {target} event handler of the hovered corner
         */
        _setCornerCursor: function(corner, target, e) {
            var iconUrlPattern = /\.(?:jpe?g|png|gif|jpg|jpeg|svg)$/;

            if (this.fixedCursors && this[corner + 'cursorIcon']) {
                if (this[corner + 'cursorIcon'].match(iconUrlPattern)) {
                    this.setCursor('url(' + this[corner + 'cursorIcon'] + '), auto');
                } else {
                    if (this[corner + 'cursorIcon'] === 'resize') {
                        this.setCursor(this._getRotatedCornerCursor(corner, target, e));
                    } else {
                        this.setCursor(this[corner + 'cursorIcon']);
                    }
                }
            } else {
                if (corner in cursorOffset) {
                    this.setCursor(this._getRotatedCornerCursor(corner, target, e));
                } else if (corner === 'mtr' && target.hasRotatingPoint) {
                    this.setCursor(this.rotationCursor);
                } else {
                    this.setCursor(this.defaultCursor);
                    return false;
                }
            }

            return false;
        },
    });

    if (typeof exports !== 'undefined') {
        module.exports = this;
    }

    /*********************************************************************************************************************************/
    /**************************************************** </CUSTOMIZE CONTROLS/> *****************************************************/
    /*********************************************************************************************************************************/


</script>