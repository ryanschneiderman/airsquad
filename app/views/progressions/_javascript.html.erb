<script>

    /*********************************************************************************************************************************/
    /**************************************************** <BUTTON FUNCTIONS> *********************************************************/
    /*********************************************************************************************************************************/
    function validateAnchor(object){
      var isValidAnchor = false;
      var object_type = object.get("type");
      if (object_type == "PlayerCircle" || object_type == "LineWithArrow" || object_type == "PassLine" || object_type == "DribbleLine" || object_type == "ScreenLine"){
        isValidAnchor = true;
      }
      return isValidAnchor;
    }


    function lineToRun(event){
        line_type = "run";
        var anchor = canvas.getActiveObject()
            if(anchor && validateAnchor(anchor) && !anchor.moveLine){
                draw(anchor);
                canvas.requestRenderAll.bind(canvas);
            }    
    }

    function lineToPass(event){
        line_type = "pass";
         var anchor = canvas.getActiveObject()
            if(anchor && validateAnchor(anchor)){
              hasBall()
              draw(anchor);
              canvas.requestRenderAll.bind(canvas);
            } 
    }

    function lineToScreen(event){
        line_type = "screen";
        var anchor = canvas.getActiveObject()
            if(anchor && validateAnchor(anchor) && !anchor.moveLine){
                draw(anchor);
                canvas.requestRenderAll.bind(canvas);
                
            } 
    }

    function lineToDribble(event){
        line_type = "dribble";
        var anchor = canvas.getActiveObject()
            if(anchor && validateAnchor(anchor) && !anchor.moveLine){
                draw(anchor);
                canvas.requestRenderAll.bind(canvas);
            } 
    }

    function setBallPos(obj){
      obj.ball.set({left: obj.left + obj.radius * 1.7, top: obj.top + obj.radius * 1.7})
      obj.ball.setCoords()
      canvas.renderAll()
    }

    

    function descendantHasBall(anchor){
      var type = anchor.get("type")
      if(validateLine(anchor) || type == "PlayerCircle"){
        var anchor_id = anchor.id.split("_")[0]
        canvas.getObjects().forEach(function(o) {
            if(o.id == anchor_id){
              if(o.has_ball){
                return true;
              }
            }
        });
      }
      return false;
    }

    function getDescendant(anchor){
      var type = anchor.get("type")
      var return_object;
      if(validateLine(anchor) || type == "PlayerCircle"){
        var anchor_id = anchor.id.split("_")[0]
        canvas.getObjects().forEach(function(o) {
            if(o.id == anchor_id && o.get("type") == "PlayerCircle"){
              return_object = o;
            }
        });
      }
      return return_object
    }

    function objectHasPassLine(player){
      if(player.passLine){
        return true;
      }
      else if (player.moveLine){
        return objectHasPassLine(player.moveLine)
      }
      else{
        return false;
      }
    }

    function hasBall(){
      var editing = false;
      if(typeof progressions_arr !== 'undefined' && typeof progressions_arr[index] !== 'undefined'){
        editing = true;
      }
      var anchor = canvas.getActiveObject()
      var ball_found = false;
      if(anchor){
        var type = anchor.get("type")
        var anchor_descendant = getDescendant(anchor)
        if(anchor_descendant){
          canvas.getObjects().forEach(function(o) {
            var descendant = getDescendant(o)
            if(descendant && descendant.has_ball){
              if(!objectHasPassLine(descendant)){
                o.has_ball = false;
                anchor.ball = o.ball;
                setBallPos(anchor)
                o.ball = null;
                anchor.has_ball = true;
                if(editing) progressions_arr[index].edited = true;
              }
              ball_found = true;
            }
          });
          if(!ball_found){
            var ball = makeBasketball(anchor.top, anchor.left, anchor.radius)
            anchor.ball = ball;
            anchor.has_ball = true;
            if(editing) progressions_arr[index].edited = true;
          }

        }
      }

      // canvas.getObjects().forEach(function(o) {
      //    if(o.get("type") == "PlayerCircle"){
      //     console.log(o)
      //    }
      // });

    }

    

    /*********************************************************************************************************************************/
    /**************************************************** <BUTTON FUNCTIONS/> *********************************************************/
    /*********************************************************************************************************************************/



    /*********************************************************************************************************************************/
    /**************************************************** <HELPER FUNCTIONS> *********************************************************/
    /*********************************************************************************************************************************/


    function setLine (LineId, obj, isMoveLine) {
        canvas.getObjects().forEach(function(o) {
            if(o.id == LineId) {
              (isMoveLine) ? obj.moveLine = o : obj.passLine = o; 
                return o;
            }
            else if (o.passerId == LineId){
              o.passer = obj.passLine
            }
        });
    }

    function setToAnchor(toAnchorId, line, centerX, centerY){
      canvas.getObjects().forEach(function(o) {
            if(o.id == toAnchorId) {
                o.set({top: centerY, left: centerX});
                line.toAnchor = o;
                return o;
            }
      });
    }

    function getToAnchor(toAnchorId, line){
       canvas.getObjects().forEach(function(o) {
            if(o.id == toAnchorId && toAnchorId != null) {
                line.toAnchor = o;
                return o;
            }
      });
    }



    function adjustChildrenAnchors(obj){
      if(obj.passLine){
        obj.passLine.set({x1: obj.toAnchorPoint.x, y1: obj.toAnchorPoint.y})
        rotateAnchor(obj.passLine)
        obj.passLine.setCoords()
      }
      if (obj.moveLine){
        obj.moveLine.set({x1: obj.toAnchorPoint.x, y1: obj.toAnchorPoint.y})
        rotateAnchor(obj.moveLine)
        obj.moveLine.setCoords()
        checkPassLine(obj.moveLine)
        adjustChildrenAnchors(obj.moveLine)
      }
    }

    function populateLines(obj){
      if(obj.passLineId){
        setLine(obj.passLineId, obj, false)
      }
      if (obj.moveLineId){
        setLine(obj.moveLineId, obj, true)
        populateLines(obj.moveLine)
      }
    }

    function rotateAnchor(line){
      var centerX = line.x2 - anchorOffset + (Math.cos(line.anchorAngle) * 10);
      var centerY = line.y2 - anchorOffset + (Math.sin(line.anchorAngle) * 10);
      setToAnchor(line.toAnchorId, line, centerX, centerY);
      line.toAnchorPoint.x = centerX + anchorOffset
      line.toAnchorPoint.y = centerY + anchorOffset;
    }


    function add_players(bench, playerRadius){
        var off1 = makeCircle(bench, canvas.height * .07, 'blue', 'off1', '1', false, playerRadius);
        var off2 = makeCircle(bench, canvas.height * .14, 'blue', 'off2', '2', false, playerRadius);
        var off3 = makeCircle(bench, canvas.height * .21, 'blue', 'off3', '3', false, playerRadius);
        var off4 = makeCircle(bench, canvas.height * .28, 'blue', 'off4', '4', false, playerRadius);
        var off5 = makeCircle(bench, canvas.height * .35, 'blue', 'off5', '5', false, playerRadius);

        var def1 = makeCircle(bench, canvas.height * .49, 'red', 'def1', '1', false, playerRadius);
        var def2 = makeCircle(bench, canvas.height * .56, 'red', 'def2', '2', false, playerRadius);
        var def3 = makeCircle(bench, canvas.height * .63, 'red', 'def3', '3', false, playerRadius);
        var def4 = makeCircle(bench, canvas.height * .7, 'red', 'def4', '4', false, playerRadius);
        var def5 = makeCircle(bench, canvas.height * .77, 'red', 'def5', '5', false, playerRadius);
    }

    function add_fullcourt_players(bench, playerRadius){
        var off1 = makeCircle(canvas.width * .20, bench, 'blue', 'off1', '1', false, playerRadius);
        var off2 = makeCircle(canvas.width * .25, bench, 'blue', 'off2', '2', false, playerRadius);
        var off3 = makeCircle(canvas.width * .30, bench, 'blue', 'off3', '3', false, playerRadius);
        var off4 = makeCircle(canvas.width * .35, bench, 'blue', 'off4', '4', false, playerRadius);
        var off5 = makeCircle(canvas.width * .40, bench, 'blue', 'off5', '5', false, playerRadius);

        var def1 = makeCircle(canvas.width * .50, bench, 'red', 'def1', '1', false, playerRadius);
        var def2 = makeCircle(canvas.width * .55, bench, 'red', 'def2', '2', false, playerRadius);
        var def3 = makeCircle(canvas.width * .60, bench, 'red', 'def3', '3', false, playerRadius);
        var def4 = makeCircle(canvas.width * .65, bench, 'red', 'def4', '4', false, playerRadius);
        var def5 = makeCircle(canvas.width * .70, bench, 'red', 'def5', '5', false, playerRadius);
    }

    function checkPassLine(obj){
      if(obj.passer){
        console.log(obj)
        adjustPassLine(obj)
      }
      else if (obj.passerId){
        canvas.getObjects().forEach(function(o) {
            if(o.id == obj.passLineId) {
                obj.passer = o;
                adjustPassLine(obj)
            }
        });
      }
    }

    function adjustPassLine(obj){
      var endpoint = findObjectEndpoint(obj)
      var pass_line_endpoint = findPassLineEndpoint(obj.passer, endpoint, obj.radius)
      obj.passer.set({x2: pass_line_endpoint.x, y2: pass_line_endpoint.y})
      obj.passer.setCoords()
      adjustLineSnap(obj.passer, obj.radius)
      obj.passer.setCoords()
      rotateAnchor(obj.passer)
    }

    function adjustLineAngle(line){
      var xDiff = line.x2 - line.x1;
      var yDiff = line.y2 - line.y1;
      var angle = Math.atan2(yDiff, xDiff);
      line.set({anchorAngle: angle})
    }

    function removePassLineRef(line){
      canvas.getObjects().forEach(function(o){
        if(o.passerId == line.id){
          o.set({passerId: null, passer: null})
        }
      });
    }

    function positionPlayer(obj){
      obj.toAnchorPoint.x = obj.left + obj.radius;
      obj.toAnchorPoint.y = obj.top + obj.radius;
      obj.text.left = obj.left + obj.radius + 2;
      obj.text.top = obj.top + obj.radius + 2;

      if(obj.has_ball){
        obj.ball.left = obj.left + obj.radius * 1.7
        obj.ball.top = obj.top + obj.radius * 1.7
      }
    }
    function positionLine(obj, x, y){
      obj.toAnchorPoint.x = x + Math.cos(obj.anchorAngle) * 10;
      obj.toAnchorPoint.y =  y + Math.sin(obj.anchorAngle) * 10;
      obj.set({x2: x, y2: y})
      obj.setCoords();
      rotateAnchor(obj);
    }

    function anchorPositioning(e){
      var obj = e.target;
      var type = obj.get('type');
      if(validateLine(obj)){
          positionLine(obj, canvas.getPointer(e.e).x, canvas.getPointer(e.e).y)
      }
      else if (type == "PlayerCircle"){
          positionPlayer(obj)
      }
      checkPassLine(obj)
      adjustChildrenAnchors(obj); 
    }

    $(document).mouseup( function(e){
      var obj = canvas.getActiveObject()
        if (obj && obj.type == 'PassLine'){
          snapPassLine(obj)
          adjustLineAngle(obj)
          rotateAnchor(obj)
        }
    });

    function boundObjects(obj){
      // if object is too big ignore
      if(obj.currentHeight > obj.canvas.height -1 || obj.currentWidth > obj.canvas.width -1){
          return;
      }        
      obj.setCoords();        
      // top-left  corner
      if(obj.getBoundingRect().top < 1 || obj.getBoundingRect().left < 1){
          obj.top = Math.max(obj.top, obj.top-obj.getBoundingRect().top);
          obj.left = Math.max(obj.left, obj.left-obj.getBoundingRect().left);
      }
          // bot-right corner
      if(obj.getBoundingRect().top+obj.getBoundingRect().height  > obj.canvas.height || obj.getBoundingRect().left+obj.getBoundingRect().width  > obj.canvas.width){
          obj.top = Math.min(obj.top, obj.canvas.height-obj.getBoundingRect().height+obj.top-obj.getBoundingRect().top);
          obj.left = Math.min(obj.left, obj.canvas.width-obj.getBoundingRect().width+obj.left-obj.getBoundingRect().left);
      }
    }

    function validateLine(obj){
      var type = obj.get("type");
      if (type == 'LineWithArrow' || type == 'ScreenLine' || type == "PassLine" || type == "DribbleLine"){
        return true;
      }
      else return false;
    }

    function getMaxDepth(obj){
      if(!obj.passLine && !obj.moveLine){
        return 0;
      }
      else{
        if(obj.moveLine){
          var max_depth = getMaxDepth(obj.moveLine)
        }
        if(obj.passLine){
          var new_depth = getMaxDepth(obj.passLine)
        }
        if(new_depth> max_depth) max_depth = new_depth;
        return max_depth + 1;
      }
    }

    function recurseAnimationTime(move_players, wait_passer, wait_receivers){
      var len = move_players.length
      var queued_actions = []
      var next_moves = []
      for(var i = 0; i < len; i++){
        //console.log(move_players[i])
        if(move_players[i].mover.passer){
          var new_wait_receiver = move_players[i]
          new_wait_receiver.passer = move_players[i].mover.passer;
          wait_receivers.push(new_wait_receiver)
        }
        else if(move_players[i].mover.passLine){
          wait_passer = move_players[i]
          wait_passer.passLine = move_players[i].mover.passLine;
        }
        else if(move_players[i].mover.moveLine){
          next_moves.push({player: move_players[i].player, mover: move_players[i].mover.moveLine})
        }
        if (move_players[i].mover.isMoveLine){
          queued_actions.push({player: move_players[i].player, mover: move_players[i].mover})
        }
      }
      return animationTimeStep(next_moves, queued_actions, wait_passer, wait_receivers)
    }

    function animationTimeStep(next_moves, queued_actions, wait_passer, wait_receivers){
      if(wait_passer && wait_receivers.length > 0){
        var receiver = pass_pair_exists(wait_passer, wait_receivers)
        if(receiver){
          next_moves = exec_simul_pass_moves(next_moves, true)
          if(wait_passer.mover && wait_passer.mover.moveLine) next_moves.push({player: wait_passer.player, mover: wait_passer.mover.moveLine});
          if(receiver.mover && receiver.mover.moveLine) next_moves.push({player: receiver.player, mover: receiver.mover.moveLine});
          if(next_moves.length> 0){
            console.log("pass and move + 2")
            return 2 + recurseAnimationTime(next_moves, null, wait_receivers);
          }
          else{
            console.log("just pass + 1")
            return 1 + recurseAnimationTime(next_moves, null, wait_receivers);
          }
        }
        else{
          console.log("non receiver + 1")
          return 1 + recurseAnimationTime(next_moves, wait_passer, wait_receivers);
        }
      }
      else if(next_moves.length > 0 ){
        console.log("next moves + 1")
        return 1 + recurseAnimationTime(next_moves, wait_passer, wait_receivers);
      }
      else {
        console.log("end + 0")
        return 0;
      }
    }

    function getAnimationTime(){
      var max_depth = 0;
      var pass_player_depth = 0;
      var wait_passer;
      var wait_receivers = [];
      var move_players = [];
      canvas.getObjects().forEach(function(o) {
        if (o.type == "PlayerCircle"){
          if(o.passLine){
            wait_passer = {player: o, mover: o, passLine: o.passLine,};
          }
          if(o.passer){
            wait_receivers.push({player: o, mover: o, passer: o.passer});
          }
          else if(o.moveLine){
            move_players.push({player: o, mover: o})
          }
        }
      });
      var time = recurseAnimationTime(move_players, wait_passer, wait_receivers)
      return time;
    }

    function initiatePass(move_players, pass_player, maxDepth){

      var max_depth = 0;
      console.log(maxDepth)
      setTimeout(function(){
          animatePass(pass_player.player, pass_player.passLine)
          if(pass_player.moveLine){
            setTimeout(function(){
              queueMovement(pass_player.player, pass_player.moveLine)
            }, animate_time);
          }
      }, animate_time * maxDepth)
    }



    //BREAK UP THIS FUNCTION 
    function animatePlayers(move_players, wait_passer, wait_receivers){
      console.log('animating players')
      var len = move_players.length
      var queued_actions = []
      var next_moves = []
      for(var i = 0; i < len; i++){
        //console.log(move_players[i])
        if(move_players[i].mover.passer){
          var new_wait_receiver = move_players[i]
          new_wait_receiver.passer = move_players[i].mover.passer;
          wait_receivers.push(new_wait_receiver)
        }
        else if(move_players[i].mover.passLine){
          wait_passer = move_players[i]
          wait_passer.passLine = move_players[i].mover.passLine;
        }
        else if(move_players[i].mover.moveLine){
          next_moves.push({player: move_players[i].player, mover: move_players[i].mover.moveLine})
        }
        if (move_players[i].mover.isMoveLine){
          queued_actions.push({player: move_players[i].player, mover: move_players[i].mover})
        }
      }
      animationStep(next_moves, queued_actions, wait_passer, wait_receivers)
    }

    function animationStep(next_moves, queued_actions, wait_passer, wait_receivers){
      // Passer and receiver are both ready
      if(wait_passer && wait_receivers.length > 0){
        ///passer and receiver are tethered to the same line
        var receiver = pass_pair_exists(wait_passer, wait_receivers)
        console.log("printing receiver!!!")
        console.log(receiver)

        if(receiver){
          console.log("receiver exists")
          // animate base action
          animateMovements(queued_actions)
          // if pass is from static player. I.e. no move into a pass
          if(queued_actions.length == 0){
            animatePass(wait_passer.player, wait_passer.passLine)
            if(receiver.mover && receiver.mover.passLine) {
              console.log("in move receiver");
              //receiver.passLine = receiver.mover.passLine;
              console.log(wait_receivers)
              wait_passer = receiver;
              console.log(wait_passer)
            }
             removeIndex = wait_receivers.map(function(item) { return item.mover.id; }).indexOf(receiver.mover.id);
            ~removeIndex && wait_receivers.splice(removeIndex, 1);
            if(wait_receivers.length != 0){
              setTimeout(function(){
                animatePlayers(next_moves, wait_passer, wait_receivers)
              }, animate_time)
              
            }
          }
          else{
            setTimeout(function(){
              animatePass(wait_passer.player, wait_passer.passLine)
               removeIndex = wait_receivers.map(function(item) { return item.mover.id; }).indexOf(receiver.mover.id);
            ~removeIndex && wait_receivers.splice(removeIndex, 1);
              next_moves = exec_simul_pass_moves(next_moves)
              setTimeout(function(){
                if(wait_passer.mover && wait_passer.mover.moveLine) next_moves.push({player: wait_passer.player, mover: wait_passer.mover.moveLine});
                wait_passer = null;
                if(receiver.mover && receiver.mover.moveLine) next_moves.push({player: receiver.player, mover: receiver.mover.moveLine});
                if(receiver.mover && receiver.mover.passLine) wait_passer = receiver;
                animatePlayers(next_moves, wait_passer, wait_receivers)
              }, animate_time)
            }, animate_time)
          }
        }
        else{
          default_animation(queued_actions, next_moves, wait_passer, wait_receivers)
        }
      }
      // Default case. Moves without any pass
      else if (queued_actions.length > 0){
        console.log("queued_actions")
        default_animation(queued_actions, next_moves, wait_passer, wait_receivers)
      }
      // Initial case. Movers are really players.
      else if(next_moves.length > 0 ){
        console.log("next moves")
        animatePlayers(next_moves, wait_passer, wait_receivers)
      }
    }

    function default_animation(queued_actions, next_moves, wait_passer, wait_receivers){
      animateMovements(queued_actions)
          setTimeout(function(){
            animatePlayers(next_moves, wait_passer, wait_receivers)
          }, animate_time)
    }

    function pass_pair_exists(passer, potential_receivers){
      var len = potential_receivers.length
      //console.log("passer")
      //console.log(passer)
      for(var i = 0; i < len; i++){
        //console.log("potential_receiver")
        //console.log(potential_receivers[i].passer.id)
        if(passer.passLine.id == potential_receivers[i].passer.id){
          //console.log("match found!!!")
          return potential_receivers[i]
        }
      }
    }

    function exec_simul_pass_moves(moves, is_calc_time){
      if(!is_calc_time) animateMovements(moves)
      var return_moves = []
      for(var i = 0; i < moves.length; i++){
        if(moves[i].mover.moveLine){
          return_moves.push({player: moves[i].player, mover: moves[i].mover.moveLine})
        }
      }
      return return_moves;
    }


    function animateMovements(moves){
      var len = moves.length
      for(var i = 0; i < len; i++){
        animateMovement(moves[i].player, moves[i].mover)
      }
    }


    function startAnimation(){
      var wait_passer;
      var wait_receivers = [];
      var move_players = [];
      var max_depth = 0;
      canvas.getObjects().forEach(function(o) {
        if (o.type == "PlayerCircle"){
          populateLines(o)
          if(o.passLine && o.has_ball){
            wait_passer = {player: o, mover: o, passLine: o.passLine,};
          }
          if(o.passer){
            wait_receivers.push({player: o, mover: o, passer: o.passer, passLine: o.passLine});
          }
          else if(o.moveLine){
            move_players.push({player: o, mover: o, passer: o.passer, passLine: o.passLine})
          }
        }
      });
      hideLines()
      animatePlayers(move_players, wait_passer, wait_receivers)
      return max_depth;
    }

    function animateMovement(player, line){
          
      var new_left = line.toAnchorPoint.x;
      var new_top = line.toAnchorPoint.y;
      
      player.animate('left', new_left - player.radius, {
        duration: animate_time,
        onChange: canvas.renderAll.bind(canvas),
      });
      player.animate('top', new_top - player.radius, {
        duration: animate_time,
        onChange: canvas.renderAll.bind(canvas),
      });

      player.text.animate('top', new_top + 2, {
        duration: animate_time,
        onChange: canvas.renderAll.bind(canvas),
      });

      player.text.animate('left', new_left+ 2, {
        duration: animate_time,
        onChange: canvas.renderAll.bind(canvas),
      });

      if(player.has_ball){
        player.ball.animate('top', new_top- player.radius + player.radius * 1.7, {
        duration: animate_time,
        onChange: canvas.renderAll.bind(canvas),
        });

        player.ball.animate('left', new_left - player.radius + player.radius * 1.7, {
          duration: animate_time,
          onChange: canvas.renderAll.bind(canvas),
        });
      }

      player.toAnchorPoint.x = new_left
      player.toAnchorPoint.y = new_top
  }

  function animatePass(player, line){
    console.log("in animate pass")
    console.log(JSON.parse(JSON.stringify(player)))
    //console.log(line)
    if(player.has_ball){
      console.log("player has ball")
        var new_left = line.toAnchorPoint.x;
        var new_top = line.toAnchorPoint.y;
        player.ball.animate('top', new_top, {
          duration: animate_time,
          onChange: canvas.renderAll.bind(canvas),
          });

        player.ball.animate('left', new_left , {
            duration: animate_time,
            onChange: canvas.renderAll.bind(canvas),
        });
        setTimeout(function(){ 
          var new_play_w_ball = closestToBall(new_left, new_top)
          setBallPlayer(new_play_w_ball)
        }, animate_time);
    }
  }

  /*  function animateMovement(player, o){
      var wait = false;
      canvas.getObjects().forEach(function(obj) {
        if (obj.anchorId == o.id && (obj.type == "LineWithArrow" || obj.type == "DribbleLine" || obj.type == "ScreenLine")){
          
          var new_left = obj.toAnchorPoint.x;
          var new_top = obj.toAnchorPoint.y;
          
          player.animate('left', new_left - player.radius, {
            duration: animate_time,
            onChange: canvas.renderAll.bind(canvas),
          });
          player.animate('top', new_top - player.radius, {
            duration: animate_time,
            onChange: canvas.renderAll.bind(canvas),
          });

          player.text.animate('top', new_top + 2, {
            duration: animate_time,
            onChange: canvas.renderAll.bind(canvas),
          });

          player.text.animate('left', new_left+ 2, {
            duration: animate_time,
            onChange: canvas.renderAll.bind(canvas),
          });

          if(player.has_ball){
            player.ball.animate('top', new_top- player.radius + player.radius * 1.7, {
            duration: animate_time,
            onChange: canvas.renderAll.bind(canvas),
            });

            player.ball.animate('left', new_left - player.radius + player.radius * 1.7, {
              duration: animate_time,
              onChange: canvas.renderAll.bind(canvas),
            });
          }

          player.toAnchorPoint.x = new_left
          player.toAnchorPoint.y = new_top

          setTimeout(function(){ 
            if (o.passLine){
              animateMovement(player, o.passLine)
            } 
            else if (o.moveLine){
              animateMovement(player, o.moveLine)
            }
          }, animate_time);
          
        }
        else if (player.has_ball && obj.anchorId == o.id && (obj.type == "PassLine" )){
          var new_left = obj.toAnchorPoint.x;
          var new_top = obj.toAnchorPoint.y;
          player.ball.animate('top', new_top, {
            duration: animate_time,
            onChange: canvas.renderAll.bind(canvas),
            });

          player.ball.animate('left', new_left , {
              duration: animate_time,
              onChange: canvas.renderAll.bind(canvas),
          });
          setTimeout(function(){ 
            var new_play_w_ball = closestToBall(new_left, new_top)
            setBallPlayer(new_play_w_ball)
          }, animate_time);
          
        }
    });
  }*/

  function setBallPlayer(player){
      var ball_found = false;
      canvas.getObjects().forEach(function(o) {
            if(o.has_ball && !ball_found){
              o.has_ball = false;
              canvas.remove(o.ball)
              o.ball = null;
              var new_ball = makeBasketball(player.top, player.left, player.radius)
              
              player.ball = new_ball
              
              setBallPos(player)
              ball_found = true;

            }
      });

      if (!ball_found){
          var ball = makeBasketball(player.top, player.left, player.radius)
          player.ball = ball;
      }
      player.has_ball = true;
    }

    function closestToBall(x, y){
      var curr_player = null;
      var min_distance = null;
      canvas.getObjects().forEach(function(o) {
        if(o.type == "PlayerCircle"){
          var player_x = o.left + o.radius;
          var player_y = o.top + o.radius;
          var dx = Math.pow(player_x - x, 2);
          var dy = Math.pow(player_y - y, 2);
          if(min_distance == null){
            curr_player = o;
            min_distance = dx + dy
          }
          else if (dx + dy < min_distance){
            min_distance = dx + dy
            curr_player = o
          }
        }
      });
      return curr_player;
    }



  function attachBallClosest(){

  }

  function hideLines(){
    canvas.getObjects().forEach(function(obj) {
      if(obj.type == 'LineWithArrow' || obj.type == 'ScreenLine' || obj.type == "DribbleLine" || obj.type == "PassLine"){
          obj.opacity = 0;
          if(obj.toAnchor){
            obj.toAnchor.opacity = 0;
          }
      }   
    });
  }

  function removeLine(obj){
    removeLineRef(obj);
    canvas.remove(obj.toAnchor);
    canvas.remove(obj);
    canvas.renderAll();
  }

  function removeLines(){
    canvas.getObjects().forEach(function(obj) {
      if(obj.type == 'LineWithArrow' || obj.type == 'ScreenLine' || obj.type == "DribbleLine" || obj.type == "PassLine"){
          removeLine(obj)
      }   
    });
  }

    /*********************************************************************************************************************************/
    /**************************************************** <HELPER FUNCTIONS/> ********************************************************/
    /*********************************************************************************************************************************/



    function deselect_all_active(){
      canvas.getActiveObjects().forEach(function(o) {
        var type = o.get('type');
            if(type == "PlayerCircle"){
                o.set({stroke: o.color});
            } 
            if(validateLine(o)){
              if(!o.toAnchor){
                getToAnchor(o.toAnchorId, o);
              }
              o.toAnchor.set('opacity', '0')
            }
      });
    }

    $(".progression-notes-text").click(function(){
      canvas.discardActiveObject();
    });
    
    $(document).keyup(function(e){
        if(e.keyCode == 46 || e.keyCode == 8) {
            canvas.getActiveObjects().forEach(function(o) {
                var type = o.get('type');
                if(type == 'LineWithArrow' || type == 'ScreenLine' || type == "PassLine" || type == "DribbleLine"){
                    removeLineRef(o);
                    canvas.remove(o.toAnchor);
                    canvas.remove(o);
                }   
        });
        }
    });


/*
    $(document).keydown(function(e) {
        if(e.keyCode == 16) {
            var anchor = canvas.getActiveObject();
            if(anchor && validateValidAnchor(anchor)){
                draw(anchor);
                canvas.renderAll();
            } 
        } 
    }
);*/



    

    /*********************************************************************************************************************************/
    /**************************************************** <DOCUMENT ON READY/> *******************************************************/
    /*********************************************************************************************************************************/


</script>